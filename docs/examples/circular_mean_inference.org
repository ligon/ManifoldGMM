#+TITLE: Circle Mean Inference on \(\mathbb{S}^1\)
#+AUTHOR: ManifoldGMM Maintainers

:SETUP:
#+OPTIONS: toc:nil num:nil
#+PROPERTY: header-args:python :exports code :noweb yes :session circle_inference :tangle ../../examples/circular_mean_inference.py
:END:

* Motivation
Circular data (wind direction, time-of-day effects, phase angles) live on the
unit circle.  A natural moment condition is
\[
  g_i(x) = x_\perp^\top z_i = 0, \qquad
  z_i = (\cos \phi_i, \sin \phi_i), \quad
  x_\perp = \begin{bmatrix}0 & -1\\ 1 & 0\end{bmatrix} x,
\]
which states that the average sine of the deviation from the population mean
direction vanishes.  We walk through the estimation and inference steps with
explicitly labelled data.

* Imports
#+name: circle-imports
#+begin_src python :session circle_inference
"""Circle mean GMM example (tangled from documentation)."""

from __future__ import annotations

import datamat as dm
import jax.numpy as jnp
import numpy as np
from datamat import DataVec
from jax.scipy.special import ndtri as normal_quantile
from manifoldgmm import GMM, Manifold, MomentRestriction
from pymanopt.manifolds import Sphere

ROT90 = jnp.array([[0.0, -1.0], [1.0, 0.0]], dtype=jnp.float64)


def gi_jax(theta: jnp.ndarray, observation: jnp.ndarray) -> jnp.ndarray:
    """Single sine moment expressed in tangent coordinates."""

    theta_perp = ROT90 @ theta
    return jnp.array([jnp.dot(theta_perp, observation)], dtype=jnp.float64)


def gaussian_quantile(confidence: float = 0.95) -> float:
    """Two-sided Gaussian critical value for a confidence level."""

    upper_tail = 0.5 + 0.5 * confidence
    return float(normal_quantile(upper_tail))
#+end_src

* Data
#+name: circle-data
#+begin_src python 

# "True" population mean angle
mu_0 = np.pi/2

# Draw 256 angles, keep them in a labelled DataMat, and build unit vectors.
angles = DataVec.random(256, rng=2025, name="phi", idxnames="obs") + mu_0

observations = dm.concat(
        {'x': np.cos(angles), 'y': np.sin(angles)},
        axis=1,
        levelnames=True,
)
#+end_src

* Restriction and Estimation
#+name: circle-estimation
#+begin_src python 
m = MomentRestriction(
        gi_jax=gi_jax,
        parameter_labels=('x','y'),
        data=observations,
        manifold=Manifold.from_pymanopt(Sphere(2)),
        backend="jax",
)

gmm = GMM(m)

result = gmm.estimate()
#+end_src

* Inference
#+name: circle-inference
#+begin_src python
tangent_cov = result.tangent_covariance()
ambient_cov = result.manifold_covariance()
standard_error = np.sqrt(ambient_cov.dg())

alpha = 0.95
z = gaussian_quantile(alpha)
confidence_interval = dm.concat({'lower':result.theta - z*standard_error,
                                 'upper':result.theta + z*standard_error},axis=1)

print("Estimate\n", result.theta)
print("Standard error\n", standard_error)
print(f"{alpha:.1%} confidence interval\n", confidence_interval)
#+end_src

* FAQ
- Why does =result.theta= show a =DataVec= while JAX still works? :: The raw optimiser output lives in =result.theta_array=; =theta= is a formatted view created via =MomentRestriction.format_parameter= so you get labels without disturbing autodiff.
- What does =tangent_covariance()= measure? :: The sandwich covariance expressed in the tangent coordinates at the estimate. On \(\mathbb{S}^1\) it’s \(1\times 1\) because the tangent space is one-dimensional.
- How do I get a \(2\times 2\) covariance? :: Use =result.manifold_covariance()= (or =ambient_covariance()=) to push the tangent variance forward into ambient coordinates.
- How is "push" related to "retract"? :: You take the covariance expressed in tangent coordinates and push it forward through the chart/Jacobian to ambient coordinates using the linear map (the manifold’s differential). It’s not the same as a “retraction” (which maps a tangent vector back onto the manifold). Here it’s about applying the Jacobian (J) to the tangent covariance (\Sigma_\text{tan}): (J \Sigma_\text{tan} J^\top)—a pushforward of the covariance, not a retraction of points.
- Why is the =x= standard error large but the =y= one tiny? :: Near \((0,1)\) the tangent direction is almost purely horizontal, so first-order fluctuations affect \(x\) much more than \(y\).
- What about bootstrap draws flipping sign? :: Align each replicate to a canonical representative (e.g., enforce \(y\ge 0\)) or report mixture-aware summaries; otherwise the dispersion will look artificially large.
- How does the manifold constraint compare to an unconstrained fit? :: The constrained estimator removes variance orthogonal to the manifold; the unconstrained sandwich would report extraneous directions that are later projected away.
