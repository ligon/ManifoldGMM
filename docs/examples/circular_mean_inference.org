#+TITLE: Circle Mean Inference on \(\mathbb{S}^1\)
#+AUTHOR: ManifoldGMM Maintainers
#+OPTIONS: toc:nil num:nil
#+PROPERTY: header-args:python :exports code :noweb yes :session circle_inference

* Motivation
Circular data (wind direction, time-of-day effects, phase angles) live on the
unit circle.  A natural moment condition is
\[
  g_i(x) = x_\perp^\top z_i = 0, \qquad
  z_i = (\cos \phi_i, \sin \phi_i), \quad
  x_\perp = \begin{bmatrix}0 & -1\\ 1 & 0\end{bmatrix} x,
\]
which states that the average sine of the deviation from the population mean
direction vanishes.  We walk through the estimation and inference steps with
explicitly labelled data.

* Imports
#+name: circle-imports
#+begin_src python :tangle ../../examples/circular_mean_inference.py :session circle_inference
"""Circle mean GMM example (tangled from documentation)."""

from __future__ import annotations

import numpy as np
import jax.numpy as jnp
from jax.scipy.special import ndtri
from datamat import DataMat, DataVec
from manifoldgmm import GMM, GMMResult, Manifold, MomentRestriction
from pymanopt.manifolds import Sphere

ROT90 = jnp.array([[0.0, -1.0], [1.0, 0.0]], dtype=jnp.float64)


def gi_jax(theta: jnp.ndarray, observation: jnp.ndarray) -> jnp.ndarray:
    """Single sine moment expressed in tangent coordinates."""

    theta_perp = ROT90 @ theta
    return jnp.array([jnp.dot(theta_perp, observation)], dtype=jnp.float64)


def gaussian_quantile(confidence: float = 0.95) -> float:
    """Two-sided Gaussian critical value for a confidence level."""

    upper_tail = 0.5 + 0.5 * confidence
    return float(jnp.asarray(ndtri(upper_tail)))
#+end_src

* Data
#+name: circle-data
#+begin_src python :session circle_inference
# Draw 256 angles, keep them in a labelled DataMat, and build unit vectors.
angles = DataMat.random((256, 1), rng=2025, columns=["phi"], idxnames="obs")
angles_rad = jnp.mod(jnp.asarray(angles.to_jax().values.squeeze()), 2 * jnp.pi)

observations = jnp.stack([jnp.cos(angles_rad), jnp.sin(angles_rad)], axis=1)
observations_dm = DataMat(
    np.column_stack(
        [
            np.cos(np.asarray(angles.to_numpy(dtype=float)).ravel()),
            np.sin(np.asarray(angles.to_numpy(dtype=float)).ravel()),
        ]
    ),
    index=angles.index,
    columns=["cos_phi", "sin_phi"],
    idxnames="obs",
)
#+end_src

* Restriction and Estimation
#+name: circle-estimation
#+begin_src python :session circle_inference
manifold = Manifold.from_pymanopt(Sphere(2))
restriction = MomentRestriction(
    gi_jax=gi_jax,
    data=observations,
    manifold=manifold,
    backend="jax",
)

gmm = GMM(
    restriction,
    initial_point=jnp.array([1.0, 0.0], dtype=jnp.float64),
)
result: GMMResult = gmm.estimate()
estimate = DataVec(np.asarray(result.theta), index=observations_dm.columns)
#+end_src

* Inference
#+name: circle-inference
#+begin_src python :session circle_inference
tangent_cov = result.tangent_covariance()
ambient_cov = result.manifold_covariance()
standard_error = DataVec(np.sqrt(np.diag(ambient_cov)), index=estimate.index)

alpha = 0.95
z = gaussian_quantile(alpha)
confidence_interval = DataMat(
    np.vstack([
        estimate.values - z * standard_error.values,
        estimate.values + z * standard_error.values,
    ]),
    index=["lower", "upper"],
    columns=estimate.index,
)

print("Estimate\n", estimate)
print("Standard error\n", standard_error)
print(f"{int(alpha * 100)}% confidence interval\n", confidence_interval)
#+end_src
